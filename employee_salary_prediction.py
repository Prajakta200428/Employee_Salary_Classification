# -*- coding: utf-8 -*-
"""Employee_salary_prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1APAG1sO-dfMzkiOBP_20xFwxDE2BFODU
"""

import pandas as pd

data=pd.read_csv('/salary.csv')

data.head(5)

data.tail()

data.shape

data.isnull().sum()

print(data.age.value_counts())

print(data['workclass'].value_counts())

data['workclass'] = data['workclass'].replace({' ?': ' Notlisted'})
data=data[data['workclass']!=' Without-pay']
data=data[data['workclass']!=' Never-worked']
print(data['workclass'].value_counts())

print(data['education-num'].value_counts())

print(data['marital-status'].value_counts())

data=data[data['marital-status']!=' Married-AF-spouse']
print(data['marital-status'].value_counts())

print(data['occupation'].value_counts())

data['occupation'] = data['occupation'].replace({' ?': ' Notlisted'})
data=data[data['occupation']!=' Armed-Forces']
print(data['occupation'].value_counts())

print(data['relationship'].value_counts())

print(data['race'].value_counts())

print(data['sex'].value_counts())

print(data['capital-gain'].value_counts())

print(data['capital-loss'].value_counts())

print(data['hours-per-week'].value_counts())

print(data['native-country'].value_counts())

data['native-country'] = data['native-country'].replace({' ?': ' Notlisted'})
data=data[data['native-country']!=' Holand-Netherlands']
print(data['native-country'].value_counts())

print(data['salary'].value_counts())

data.shape

data.drop(columns=['education'],inplace=True)
data

print(data.select_dtypes(include='number').columns)

#outlier detection
import seaborn as sns
sns.boxplot(data['age'])

q1 = data['age'].quantile(0.25)
q3 = data['age'].quantile(0.75)
iqr = q3-q1
q1,q3,iqr

lb = q1 - 0.5*iqr
ub = q3 + 1.5*iqr
lb,ub

data = data[data['age'].between(lb,ub)]
sns.boxplot(data['age'])

sns.boxplot(data['education-num'])

q1 = data['education-num'].quantile(0.25)
q3 = data['education-num'].quantile(0.75)
iqr = q3-q1
q1,q3,iqr

lb = q1 - 1.5*iqr
ub = q3 + 0.8*iqr
lb,ub

data = data[data['education-num'].between(lb,ub)]
sns.boxplot(data['education-num'])

from sklearn.preprocessing import LabelEncoder
encoder=LabelEncoder()
data['workclass']=encoder.fit_transform(data['workclass'])
data['marital-status']=encoder.fit_transform(data['marital-status'])
data['occupation']=encoder.fit_transform(data['occupation'])
data['relationship']=encoder.fit_transform(data['relationship'])
data['race']=encoder.fit_transform(data['race'])
data['sex']=encoder.fit_transform(data['sex'])
data['native-country']=encoder.fit_transform(data['native-country'])
data

x=data.drop(columns=['salary'])
y=data['salary']

x

y

!pip install xgboost catboost lightgbm
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier, HistGradientBoostingClassifier
from sklearn.neural_network import MLPClassifier
from lightgbm import LGBMClassifier
from catboost import CatBoostClassifier
from sklearn.model_selection import train_test_split

# Split data
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# Define models
models = {
    "LogisticRegression": LogisticRegression(max_iter=1000),
    "RandomForest": RandomForestClassifier(n_estimators=100, random_state=42),
    "GradientBoosting": GradientBoostingClassifier(n_estimators=100, learning_rate=0.1, random_state=42),
    "HistGradientBoosting": HistGradientBoostingClassifier(random_state=42),
    "MLPClassifier": MLPClassifier(hidden_layer_sizes=(100, 50), max_iter=300, random_state=42),
    "LightGBM": LGBMClassifier(random_state=42),
    "CatBoost": CatBoostClassifier(verbose=0, random_state=42)
}

from sklearn.pipeline import Pipeline
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.preprocessing import StandardScaler
import joblib

results = {}

print("\nModel Performance Summary:\n" + "-"*30)

for name, model in models.items():
    pipe = Pipeline([
        ('scaler', StandardScaler()),
        ('model', model)
    ])

    pipe.fit(x_train, y_train)
    y_pred = pipe.predict(x_test)

    acc = accuracy_score(y_test, y_pred)
    results[name] = acc

    print(f"\n{name}")
    print(f"Accuracy: {acc:.4f}")
    print(classification_report(y_test, y_pred))

# Plotting Accuracy Comparison
result_df = pd.DataFrame(list(results.items()), columns=['Model', 'Accuracy'])
result_df.sort_values(by='Accuracy', ascending=False, inplace=True)

plt.figure(figsize=(10,6))
sns.barplot(data=result_df, x='Accuracy', y='Model', hue='Model', palette='viridis', dodge=False, legend=False)
plt.title("Model Accuracy Comparison", fontsize=14)
plt.xlabel("Accuracy")
plt.ylabel("Model")
plt.xlim(0, 1)
plt.grid(True, axis='x', linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

# Get best model
best_model_name = max(results, key=results.get)
best_model = models[best_model_name]
print(f"\nBest model: {best_model_name} with accuracy = {results[best_model_name]:.4f}")

# Save the best model
joblib.dump(best_model, "best_model.pkl")
print("Saved best model as best_model.pkl")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import joblib
# 
# # Load the trained model
# model = joblib.load("best_model.pkl")
# 
# 
# 
# # Label encoders used in training ‚Äî must match exactly!
# education_map = {
#     "Bachelors": 0, "Masters": 1, "PhD": 2, "HS-grad": 3,
#     "Assoc": 4, "Some-college": 5
# }
# marital_map = {
#     "Never-married": 0, "Married": 1, "Divorced": 2,
#     "Separated": 3, "Widowed": 4
# }
# occupation_map = {
#     "Tech-support": 0, "Craft-repair": 1, "Other-service": 2, "Sales": 3,
#     "Exec-managerial": 4, "Prof-specialty": 5, "Handlers-cleaners": 6,
#     "Machine-op-inspct": 7, "Adm-clerical": 8, "Farming-fishing": 9,
#     "Transport-moving": 10, "Priv-house-serv": 11,
#     "Protective-serv": 12, "Armed-Forces": 13
# }
# workclass_map = {
#     "Private": 0, "Self-emp-not-inc": 1, "Self-emp-inc": 2,
#     "Federal-gov": 3, "Local-gov": 4, "State-gov": 5,
#     "Without-pay": 6, "Never-worked": 7
# }
# relationship_map = {
#     "Husband": 0, "Wife": 1, "Own-child": 2,
#     "Not-in-family": 3, "Unmarried": 4, "Other-relative": 5
# }
# country_map = {
#     "United-States": 0, "India": 1, "Mexico": 2,
#     "Philippines": 3, "Germany": 4, "Canada": 5,
#     "China": 6, "England": 7
# }
# sex_map = {
#     "Male": 0, "Female": 1
# }
# race_map = {
#     "White": 0, "Black": 1, "Asian-Pac-Islander": 2,
#     "Amer-Indian-Eskimo": 3, "Other": 4
# }
# 
# # Streamlit UI
# st.set_page_config(page_title="Employee Salary Classifier", page_icon="üìä", layout="wide")
# 
# st.markdown("""
#     <style>
#         html, body, [class*="css"] {
#             font-family: 'Segoe UI', sans-serif;
#         }
#         h1 { color: #003366; }
#         .subheader { color: #444; font-size: 17px; }
#         .stButton > button {
#             background-color: #004080;
#             color: white;
#             border-radius: 6px;
#         }
#         .stButton > button:hover {
#             background-color: #0059b3;
#         }
#     </style>
# """, unsafe_allow_html=True)
# 
# st.markdown("<h1 style='text-align: center;'>üìä Employee Salary Classification</h1>", unsafe_allow_html=True)
# st.markdown("<p class='subheader' style='text-align: center;'>Predict whether an employee earns >50K or ‚â§50K</p>", unsafe_allow_html=True)
# 
# col1, col2, col3 = st.columns(3)
# 
# with col1:
#     age = st.slider("Age", 18, 65, 30)
#     education = st.selectbox("Education Level", list(education_map.keys()))
#     marital_status = st.selectbox("Marital Status", list(marital_map.keys()))
#     race = st.selectbox("Race", list(race_map.keys()))
# 
# with col2:
#     occupation = st.selectbox("Occupation", list(occupation_map.keys()))
#     workclass = st.selectbox("Work Class", list(workclass_map.keys()))
#     relationship = st.selectbox("Relationship", list(relationship_map.keys()))
#     sex = st.selectbox("Sex", list(sex_map.keys()))
# 
# with col3:
#     experience = st.slider("Years of Experience", 0, 40, 5)
#     hours_per_week = st.slider("Hours per Week", 1, 80, 40)
#     capital_gain = st.number_input("Capital Gain", 0, 99999, 0)
#     capital_loss = st.number_input("Capital Loss", 0, 99999, 0)
#     native_country = st.selectbox("Country", list(country_map.keys()))
# 
# # Build input DataFrame
# input_df = pd.DataFrame({
#     'age': [age],
#     'education': [education_map[education]],
#     'marital-status': [marital_map[marital_status]],
#     'occupation': [occupation_map[occupation]],
#     'workclass': [workclass_map[workclass]],
#     'relationship': [relationship_map[relationship]],
#     'sex': [sex_map[sex]],
#     'race': [race_map[race]],
#     'capital-gain': [capital_gain],
#     'capital-loss': [capital_loss],
#     'native-country': [country_map[native_country]],
#     'experience': [experience],
#     'hours-per-week': [hours_per_week]
# })
# 
# st.markdown("#### üìä Input Summary")
# st.dataframe(input_df)
# 
# # Predict
# if st.button("üöÄ Predict Salary Class"):
#     try:
#         prediction = model.predict(input_df)
#         st.success(f"‚úÖ Prediction: `{prediction[0]}`")
#     except Exception as e:
#         st.error(f"‚ùå Prediction failed: {e}")
# 
#

!pip install streamlit pyngrok

!ngrok authtoken 30Z9UMuOC8JCYLeDs4fNxAiKt78_7qpxQ6hGGabUVKnZHwBDd

!pkill -f ngrok
!ps aux | grep ngrok

import os
import threading
def run_streamlit():
    os.system('streamlit run app.py --server.port 8501')
thread = threading.Thread(target=run_streamlit)
thread.start()

from pyngrok import ngrok
import time
time.sleep(15)
public_url = ngrok.connect(8501)
print('app live here: ',public_url)

